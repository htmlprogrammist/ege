"""
Задание 27 (№1208).
Имеется набор данных, состоящий из N троек натуральных чисел. Составьте сумму из N чисел,
выбрав из каждой тройки ровно одно число так, чтобы эта сумма не делилась нацело на k = 103 и
была максимально возможной. Гарантируется, что искомую сумму получить можно.
Входные данные:
Даны два входных файла (файл А и файл В), каждый из которых содержит в первой строке количество троек N
(1 ≤ N ≤ 1000000). Каждая из следующих N строк содержит три натуральных числа, не превышающих 10000.
Пример организации исходных данных во входном файле:
6
1 3 7
5 12 6
6 9 11
5 4 8
3 5 4
1 1 1
Для указанных входных данных в случае, если k = 5, искомой суммой является число 44.
В ответе укажите два числа: значение искомой суммы сначала для файла A, затем для файла B.
Предупреждение: для обработки файла B не следует использовать переборный алгоритм,
вычисляющий сумму для всех возможных вариантов, поскольку написанная по такому алгоритму программа
будет выполняться слишком долго.

A - 720367
"""
# 1 метод - Алексей Кабанов - "На отвали"
# f = open('27_test.txt')
f = open('27_A.txt')
n = int(f.readline())
s = [0]  # некое множество сумм, всевозможных сумм из троек
# for _ in range(n):
#     # troika = [int(x) for x in f.readline().split()]  # Алексей Кабанов
#     troika = list(map(int, f.readline().split()))  # My implementation
#     s = [a + b for a in s for b in troika]  # перебираем всевозможные варианты сумм троек
#     # причем растёт длина в геометрической прогрессии (3, 9, 27...)
#     # print(s)
#     # input()  # чтобы можно было контролировать вывод в цикле
# print(max(x for x in s if x % 5 != 0))  # в примере (в условии) указано при k = 5
# Но проблема в том, что даже в 27_А нам уже будет кабзда. Придётся немного переделать

for _ in range(n):
    # troika = [int(x) for x in f.readline().split()]  # Алексей Кабанов
    troika = list(map(int, f.readline().split()))  # My implementation
    new_s = [a + b for a in s for b in troika]
    new_s.sort()  # Отстортируем всевозможные суммы, потому что нам не нужны все суммы
    # Нам нужны только самые большие
    s = new_s[-1000:]  # Будем брать максимум тысячу сумм, но самых больших
    # NB! Опасный способ! Всё может пойти к "чертовой бабушке" (прямая цитата), но этот пример сложен будет, так что
    # вряд-ли будет

print(max(x for x in s if x % 103 != 0))
